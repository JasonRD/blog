<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="日常 operator 开发中经常使用 informer，但是对内部实现并不了解，本文对informer 实现进行深度探究，便于日后开发中问题分析"><title>informer 内部实现探究</title><link rel=canonical href=https://jasonrd.github.io/blog/p/client-go-informer/><link rel=stylesheet href=/blog/scss/style.min.8191399262444ab68b72a18c97392f5349be20a1615d77445be51e974c144cff.css><meta property="og:title" content="informer 内部实现探究"><meta property="og:description" content="日常 operator 开发中经常使用 informer，但是对内部实现并不了解，本文对informer 实现进行深度探究，便于日后开发中问题分析"><meta property="og:url" content="https://jasonrd.github.io/blog/p/client-go-informer/"><meta property="og:site_name" content="jason's 博客"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:published_time" content="2021-10-15T00:00:00+00:00"><meta property="article:modified_time" content="2021-10-15T00:00:00+00:00"><meta property="og:image" content="https://jasonrd.github.io/blog/p/client-go-informer/informer-arch.png"><meta name=twitter:site content="@jasonxie666"><meta name=twitter:creator content="@jasonxie666"><meta name=twitter:title content="informer 内部实现探究"><meta name=twitter:description content="日常 operator 开发中经常使用 informer，但是对内部实现并不了解，本文对informer 实现进行深度探究，便于日后开发中问题分析"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jasonrd.github.io/blog/p/client-go-informer/informer-arch.png"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/blog/><img src=/blog/img/avatar_hu92a1f0f4dac05816138a9efb01424f59_787601_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a>
<span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/blog>jason's 博客</a></h1><h2 class=site-description>Welcom</h2></div></header><ol class=social-menu><li><a href=https://github.com/JasonRD target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com/jasonxie666 target=_blank title=Twitter rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/blog/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>主页</span></a></li><li><a href=/blog/%E5%85%B3%E4%BA%8E/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>关于</span></a></li><li><a href=/blog/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/blog/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><li><a href=/blog/links/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg><span>Links</span></a></li><div class=menu-bottom-section><li id=i18n-switch><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg><select name=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://jasonrd.github.io/blog/en/>English</option><option value=https://jasonrd.github.io/blog/ selected>中文</option></select></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#使用套路>使用套路</a></li><li><a href=#执行逻辑>执行逻辑</a><ol><li><a href=#eventhandler-回调函数注册和执行过程>eventhandler 回调函数注册和执行过程</a></li><li><a href=#更新-indexer-缓存和-deltas-evnet-事件处理>更新 indexer 缓存和 deltas evnet 事件处理</a></li><li><a href=#list-watch-资源-event-事件和-deltas-event-生产>list watch 资源 Event 事件和 deltas event 生产</a></li></ol></li><li><a href=#主要对象数据结构>主要对象数据结构</a><ol><li><a href=#controller>Controller</a></li><li><a href=#reflector>reflector</a></li><li><a href=#sharedprocessor>sharedProcessor</a></li><li><a href=#processlistner>processListner</a></li></ol></li><li><a href=#疑问>疑问</a><ol><li><a href=#为什么需要-waitforcachesync>为什么需要 waitForCacheSync</a></li><li><a href=#为什么使用-workqueue->为什么使用 workqueue ？</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/blog/p/client-go-informer/><img src=/blog/p/client-go-informer/informer-arch_hu99f14accc96104069d2695ab8dd85549_718091_800x0_resize_box_3.png srcset="/blog/p/client-go-informer/informer-arch_hu99f14accc96104069d2695ab8dd85549_718091_800x0_resize_box_3.png 800w, /blog/p/client-go-informer/informer-arch_hu99f14accc96104069d2695ab8dd85549_718091_1600x0_resize_box_3.png 1600w" width=800 height=595 loading=lazy alt="Featured image of post informer 内部实现探究"></a></div><div class=article-details><header class=article-category><a href=/blog/categories/kubernetes/ style=background-color:#2a9d8f;color:#fff>kubernetes</a>
<a href=/blog/categories/client-go/>client-go</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/blog/p/client-go-informer/>informer 内部实现探究</a></h2><h3 class=article-subtitle>日常 operator 开发中经常使用 informer，但是对内部实现并不了解，本文对informer 实现进行深度探究，便于日后开发中问题分析</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Oct 15, 2021</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 11 分钟</time></div></footer></div></header><section class=article-content><h2 id=使用套路>使用套路</h2><p>informer 使用套路（其中略去一些细节，具体参考<a class=link href=https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go target=_blank rel=noopener>informers demo</a>）:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># 1. 创建 k8s client 对象：
</span></span><span class=line><span class=cl>cfg, err = clientcmd.BuildConfigFromFlags(masterURL, kubeconfig)
</span></span><span class=line><span class=cl>kube_client, err = kubernetes.NewForConfig(cfg)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 2. 创建资源 informer，以 POD 为例：
</span></span><span class=line><span class=cl>factory = kubeinformers.NewSharedInformerFactory(client, 0)
</span></span><span class=line><span class=cl>pod_informer = ctrl.factory.Core().V1().Pods()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 3. 注册回调函数，用来处理 Add、Update、Delete 事件：
</span></span><span class=line><span class=cl>pod_informer.Informer().AddEventHandler(handler)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>handler 实现了 OnAdd、OnUpdate、OnDelete 三个接口的:
</span></span><span class=line><span class=cl>type handler struct  {
</span></span><span class=line><span class=cl>    queue: workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter())
</span></span><span class=line><span class=cl>    OnAdd: func (obj interface{}) {
</span></span><span class=line><span class=cl>        ......
</span></span><span class=line><span class=cl>        queue.Add(cache.MetaNamespaceKeyFunc(obj))
</span></span><span class=line><span class=cl>        ......
</span></span><span class=line><span class=cl>    },
</span></span><span class=line><span class=cl>    OnUpdate: func(obj, obj interface{}) {
</span></span><span class=line><span class=cl>        ......
</span></span><span class=line><span class=cl>        queue.Add(cache.MetaNamespaceKeyFunc(obj))
</span></span><span class=line><span class=cl>        ......
</span></span><span class=line><span class=cl>    },
</span></span><span class=line><span class=cl>    OnDelete: func(obj interface{}) {
</span></span><span class=line><span class=cl>        ......
</span></span><span class=line><span class=cl>        cache.DeletionHandlingMetaNamespaceKeyFunc(obj)
</span></span><span class=line><span class=cl>        ......
</span></span><span class=line><span class=cl>    },
</span></span><span class=line><span class=cl>    Task: func() {
</span></span><span class=line><span class=cl>        key, quit := c.queue.Get()
</span></span><span class=line><span class=cl>        defer c.queue.Done(key)
</span></span><span class=line><span class=cl>        ......
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 4. 启动 informer 
</span></span><span class=line><span class=cl>factory.Start(stop)
</span></span></code></pre></td></tr></table></div></div><p>informers 包中提供了工厂类，通过调用接口<code>factory.Core().V1().Pods()</code>创建 k8s pod informer 对象，其他 k8s 内置资源类同。informer 封装都在 <code>k8s.io/client-go/pkg/informers</code> 包中。</p><h2 id=执行逻辑>执行逻辑</h2><p><img src=/blog/p/client-go-informer/img/informer-arch.png width=1438 height=1070 srcset="/blog/p/client-go-informer/img/informer-arch_hu99f14accc96104069d2695ab8dd85549_718091_480x0_resize_box_3.png 480w, /blog/p/client-go-informer/img/informer-arch_hu99f14accc96104069d2695ab8dd85549_718091_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=134 data-flex-basis=322px></p><h3 id=eventhandler-回调函数注册和执行过程>eventhandler 回调函数注册和执行过程</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type sharedIndexInformer struct {
</span></span><span class=line><span class=cl>    // 带索引资源 cache
</span></span><span class=line><span class=cl>    indexer    Indexer
</span></span><span class=line><span class=cl>    // 资源控制器，负责:
</span></span><span class=line><span class=cl>    // 1. 启动 reflector list&amp;watch;
</span></span><span class=line><span class=cl>    // 2. Add、Update、Delete 事件发生时，通知 processor 执行订阅任务；
</span></span><span class=line><span class=cl>    // 3. 以及cache缓存更新，处理逻辑在 sharedIndexInformer.HandleDeltas；
</span></span><span class=line><span class=cl>    // controller 对象在执行 sharedIndexInformer.Run 函数时初始化
</span></span><span class=line><span class=cl>    controller Controller
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // 负责事件触发时，执行订阅者的 OnAdd、OnUpdate、OnDelete 回调逻辑 
</span></span><span class=line><span class=cl>    processor             *sharedProcessor
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // list&amp;watch 资源变化，watch 通过 chunk 实现资源发生变更时进行推送
</span></span><span class=line><span class=cl>    listerWatcher ListerWatcher
</span></span><span class=line><span class=cl>    // 关注的资源类型
</span></span><span class=line><span class=cl>    objectType    runtime.Object
</span></span><span class=line><span class=cl>    .......
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>sharedIndexInformer 对象被创建后，执行 <code>Run</code> 函数启动事件监听：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (s *sharedIndexInformer) Run(stopCh &lt;-chan struct{}) {
</span></span><span class=line><span class=cl>    defer utilruntime.HandleCrash()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // 先入先出队列
</span></span><span class=line><span class=cl>    fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, s.indexer)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    cfg := &amp;Config{
</span></span><span class=line><span class=cl>        Queue:            fifo,
</span></span><span class=line><span class=cl>        ListerWatcher:    s.listerWatcher,
</span></span><span class=line><span class=cl>        ObjectType:       s.objectType,
</span></span><span class=line><span class=cl>        FullResyncPeriod: s.resyncCheckPeriod,
</span></span><span class=line><span class=cl>        RetryOnError:     false,
</span></span><span class=line><span class=cl>        ShouldResync:     s.processor.shouldResync,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        // 消费 fifo 队列，在 controller.processLoop 函数中执行
</span></span><span class=line><span class=cl>        Process: s.HandleDeltas,
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // 减小锁粒度
</span></span><span class=line><span class=cl>    func() {
</span></span><span class=line><span class=cl>        s.startedLock.Lock()
</span></span><span class=line><span class=cl>        defer s.startedLock.Unlock()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        // 初始化 controller
</span></span><span class=line><span class=cl>        s.controller = New(cfg)
</span></span><span class=line><span class=cl>        s.controller.(*controller).clock = s.clock
</span></span><span class=line><span class=cl>        s.started = true
</span></span><span class=line><span class=cl>    }()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    ......
</span></span><span class=line><span class=cl>    // 首先启动事件处理器，监听事件通知
</span></span><span class=line><span class=cl>    wg.StartWithChannel(processorStopCh, s.processor.run)
</span></span><span class=line><span class=cl>    ......
</span></span><span class=line><span class=cl>    // 启动 controller
</span></span><span class=line><span class=cl>    s.controller.Run(stopCh)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>在了解 <code>processor.run</code> 函数逻辑前，先了解一下我们关注的事件回调函数是如何注册的。在调用 sharedIndexInformer.AddEventHandler(handler) 实际上就是创建一个 processListner 事件监听器，然后注册到 processor 中进行事件监听：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (s *sharedIndexInformer) AddEventHandlerWithResyncPeriod(handler ResourceEventHandler, resyncPeriod time.Duration) {
</span></span><span class=line><span class=cl>    ......
</span></span><span class=line><span class=cl>    listener := newProcessListener(handler, resyncPeriod, determineResyncPeriod(resyncPeriod, s.resyncCheckPeriod), s.clock.Now(), initialBufferSize)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    ......
</span></span><span class=line><span class=cl>    // 注册到 processor listeners 数组中
</span></span><span class=line><span class=cl>    s.processor.addListener(listener)
</span></span><span class=line><span class=cl>    ......
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>明白了回调函数如何注册的，接下来看一下 <code>processor.run</code> 函数，了解一下什么时候执行回调函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (p *sharedProcessor) run(stopCh &lt;-chan struct{}) {
</span></span><span class=line><span class=cl>    // 细粒度锁
</span></span><span class=line><span class=cl>    func() {
</span></span><span class=line><span class=cl>        p.listenersLock.RLock()
</span></span><span class=line><span class=cl>        defer p.listenersLock.RUnlock()
</span></span><span class=line><span class=cl>        // 异步启动所有监听器，完成事件的消费
</span></span><span class=line><span class=cl>        for _, listener := range p.listeners {
</span></span><span class=line><span class=cl>            p.wg.Start(listener.run)
</span></span><span class=line><span class=cl>            p.wg.Start(listener.pop)
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        p.listenersStarted = true
</span></span><span class=line><span class=cl>    }()
</span></span><span class=line><span class=cl>    &lt;-stopCh
</span></span><span class=line><span class=cl>    p.listenersLock.RLock()
</span></span><span class=line><span class=cl>    defer p.listenersLock.RUnlock()
</span></span><span class=line><span class=cl>    for _, listener := range p.listeners {
</span></span><span class=line><span class=cl>        close(listener.addCh) // Tell .pop() to stop. .pop() will tell .run() to stop
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    p.wg.Wait() // Wait for all .pop() and .run() to stop
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>上面函数中 <code>listener.run</code> 和 <code>listener.pop</code> 函数，两个函数配合完成收到事件，并执行回调：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// 消费 processor 广播的事件，并通过 channel 内部转发
</span></span><span class=line><span class=cl>// 这个函数挺有意思，通过两个 channel 完成事件的缓存和通知。通过 addCh 无缓存 channel 通知。
</span></span><span class=line><span class=cl>// 首次函数启动或通知事件消费完成，nextCh 为 nil，第一个 case 会一直阻塞到新事件过来
</span></span><span class=line><span class=cl>// 如果事件通知速度大于消费速度，会将事件缓存在 pendingNotifications 先入先出队列，然后异步消费
</span></span><span class=line><span class=cl>func (p *processorListener) pop() {
</span></span><span class=line><span class=cl>    defer utilruntime.HandleCrash()
</span></span><span class=line><span class=cl>    defer close(p.nextCh) // Tell .run() to stop
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    var nextCh chan&lt;- interface{}
</span></span><span class=line><span class=cl>    var notification interface{}
</span></span><span class=line><span class=cl>    for {
</span></span><span class=line><span class=cl>        select {
</span></span><span class=line><span class=cl>        // 1 listener 内部广播事件
</span></span><span class=line><span class=cl>        case nextCh &lt;- notification:
</span></span><span class=line><span class=cl>            // Notification dispatched
</span></span><span class=line><span class=cl>            var ok bool
</span></span><span class=line><span class=cl>            // 2 消费缓存事件
</span></span><span class=line><span class=cl>            notification, ok = p.pendingNotifications.ReadOne()
</span></span><span class=line><span class=cl>            if !ok { // Nothing to pop
</span></span><span class=line><span class=cl>                nextCh = nil // Disable this select case
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        // 3 接收 processor 通知事件
</span></span><span class=line><span class=cl>        case notificationToAdd, ok := &lt;-p.addCh:
</span></span><span class=line><span class=cl>            if !ok {
</span></span><span class=line><span class=cl>                return
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            // 4 notification 为 nil 说明没有未消费的事件，之间内部广播
</span></span><span class=line><span class=cl>            if notification == nil { 
</span></span><span class=line><span class=cl>                notification = notificationToAdd
</span></span><span class=line><span class=cl>                nextCh = p.nextCh
</span></span><span class=line><span class=cl>            // 5 来不及消费，先暂存
</span></span><span class=line><span class=cl>            } else { 
</span></span><span class=line><span class=cl>                p.pendingNotifications.WriteOne(notificationToAdd)
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>下面使用了 wait.Until 函数，在闭包执行完成后，间隔1分钟再次执行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (p *processorListener) run() {
</span></span><span class=line><span class=cl>    stopCh := make(chan struct{})
</span></span><span class=line><span class=cl>    wait.Until(func() {
</span></span><span class=line><span class=cl>        // this gives us a few quick retries before a long pause and then a few more quick retries
</span></span><span class=line><span class=cl>        err := wait.ExponentialBackoff(retry.DefaultRetry, func() (bool, error) {
</span></span><span class=line><span class=cl>            // 我们关注回调真正的执行地方
</span></span><span class=line><span class=cl>            // p.nextCh 无缓冲 channel 由上面 pop 函数传入事件
</span></span><span class=line><span class=cl>            for next := range p.nextCh {
</span></span><span class=line><span class=cl>                switch notification := next.(type) {
</span></span><span class=line><span class=cl>                case updateNotification:
</span></span><span class=line><span class=cl>                    p.handler.OnUpdate(notification.oldObj, notification.newObj)
</span></span><span class=line><span class=cl>                case addNotification:
</span></span><span class=line><span class=cl>                    p.handler.OnAdd(notification.newObj)
</span></span><span class=line><span class=cl>                case deleteNotification:
</span></span><span class=line><span class=cl>                    p.handler.OnDelete(notification.oldObj)
</span></span><span class=line><span class=cl>                default:
</span></span><span class=line><span class=cl>                    utilruntime.HandleError(fmt.Errorf(&#34;unrecognized notification: %#v&#34;, next))
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            // the only way to get here is if the p.nextCh is empty and closed
</span></span><span class=line><span class=cl>            return true, nil
</span></span><span class=line><span class=cl>        })
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        // the only way to get here is if the p.nextCh is empty and closed
</span></span><span class=line><span class=cl>        if err == nil {
</span></span><span class=line><span class=cl>            close(stopCh)
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }, 1*time.Minute, stopCh)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><h3 id=更新-indexer-缓存和-deltas-evnet-事件处理>更新 indexer 缓存和 deltas evnet 事件处理</h3><p>HandleDeltas 函数实现了 fifo 队列消费逻辑，分别对各事件类型分别操作 indexer 索引缓存和通知 processor 向订阅者分发事件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// 处理 fifo 弹出事件
</span></span><span class=line><span class=cl>func (s *sharedIndexInformer) HandleDeltas(obj interface{}) error {
</span></span><span class=line><span class=cl>    .......
</span></span><span class=line><span class=cl>    for _, d := range obj.(Deltas) {
</span></span><span class=line><span class=cl>        switch d.Type {
</span></span><span class=line><span class=cl>        case Sync, Added, Updated:
</span></span><span class=line><span class=cl>            ......
</span></span><span class=line><span class=cl>            if old, exists, err := s.indexer.Get(d.Object); err == nil &amp;&amp; exists {
</span></span><span class=line><span class=cl>                if err := s.indexer.Update(d.Object); err != nil {
</span></span><span class=line><span class=cl>                    return err
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                // 通知 processor 向订阅者广播事件
</span></span><span class=line><span class=cl>                s.processor.distribute(updateNotification{oldObj: old, newObj: d.Object}, isSync)
</span></span><span class=line><span class=cl>            } else {
</span></span><span class=line><span class=cl>                if err := s.indexer.Add(d.Object); err != nil {
</span></span><span class=line><span class=cl>                    return err
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                s.processor.distribute(addNotification{newObj: d.Object}, isSync)
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        case Deleted:
</span></span><span class=line><span class=cl>            if err := s.indexer.Delete(d.Object); err != nil {
</span></span><span class=line><span class=cl>                return err
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            s.processor.distribute(deleteNotification{oldObj: d.Object}, false)
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    return nil
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>HandleDeltas 函数的执行时在 controller 启动时，每秒钟调用 <code>controller.processLoop</code> 消费 DeltaFIFO 中事件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (c *controller) Run(stopCh &lt;-chan struct{}) {
</span></span><span class=line><span class=cl>    ......
</span></span><span class=line><span class=cl>    r := NewReflector(
</span></span><span class=line><span class=cl>        c.config.ListerWatcher,
</span></span><span class=line><span class=cl>        c.config.ObjectType,
</span></span><span class=line><span class=cl>        c.config.Queue,
</span></span><span class=line><span class=cl>        c.config.FullResyncPeriod,
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>    ........
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    wg.StartWithChannel(stopCh, r.Run)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    wait.Until(c.processLoop, time.Second, stopCh)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>消费 listwatch 写入 DeltaFIFO 的事件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (c *controller) processLoop() {
</span></span><span class=line><span class=cl>    for {
</span></span><span class=line><span class=cl>        // 弹出第一个事件，并消费
</span></span><span class=line><span class=cl>        // c.config.Process = sharedIndexInformer.HandleDeltas
</span></span><span class=line><span class=cl>        obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))
</span></span><span class=line><span class=cl>        if err != nil {
</span></span><span class=line><span class=cl>            if err == FIFOClosedError {
</span></span><span class=line><span class=cl>                return
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            if c.config.RetryOnError {
</span></span><span class=line><span class=cl>                // This is the safe way to re-enqueue.
</span></span><span class=line><span class=cl>                c.config.Queue.AddIfNotPresent(obj)
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><h3 id=list-watch-资源-event-事件和-deltas-event-生产>list watch 资源 Event 事件和 deltas event 生产</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// Run starts a watch and handles watch events. Will restart the watch if it is closed.
</span></span><span class=line><span class=cl>// Run will exit when stopCh is closed.
</span></span><span class=line><span class=cl>func (r *Reflector) Run(stopCh &lt;-chan struct{}) {
</span></span><span class=line><span class=cl>    klog.V(3).Infof(&#34;Starting reflector %v (%s) from %s&#34;, r.expectedType, r.resyncPeriod, r.name)
</span></span><span class=line><span class=cl>    wait.Until(func() {
</span></span><span class=line><span class=cl>        if err := r.ListAndWatch(stopCh); err != nil {
</span></span><span class=line><span class=cl>            utilruntime.HandleError(err)
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }, r.period, stopCh)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>controller 启动 reflector，间隔 r.period 时间，通过 reflector.ListAndWatch 函数获取最新事件。</p><p>reflector.ListAndWatch 代码较长，就不在此列出，简单讲一下执行逻辑：</p><ol><li>首先通过 List 方法，一次性拉取所有资源，并获取最新 resourceVersion；</li><li>根据需要，启动定时异步 List 协程；</li><li>watch 资源直到 informer 退出。调用 watchHandler 获取资源变更（watch 使用 http 协议 chunk 机制完成）。对 response 反序列化成内部资源对象 <code>event.Object</code>，根据 <code>event.Type</code> 执行 <code>r.store</code> 更新、删除、新增（其中，r.store 为 DeltaFIFO）；</li></ol><h2 id=主要对象数据结构>主要对象数据结构</h2><h3 id=controller>Controller</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// Controller is a generic controller framework.
</span></span><span class=line><span class=cl>type controller struct {
</span></span><span class=line><span class=cl>    config         Config
</span></span><span class=line><span class=cl>    reflector      *Reflector
</span></span><span class=line><span class=cl>    reflectorMutex sync.RWMutex
</span></span><span class=line><span class=cl>    clock          clock.Clock
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><h3 id=reflector>reflector</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// Reflector watches a specified resource and causes all changes to be reflected in the given store.
</span></span><span class=line><span class=cl>type Reflector struct {
</span></span><span class=line><span class=cl>    // name identifies this reflector. By default it will be a file:line if possible.
</span></span><span class=line><span class=cl>    name string
</span></span><span class=line><span class=cl>    // metrics tracks basic metric information about the reflector
</span></span><span class=line><span class=cl>    metrics *reflectorMetrics
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // The type of object we expect to place in the store.
</span></span><span class=line><span class=cl>    expectedType reflect.Type
</span></span><span class=line><span class=cl>    // The destination to sync up with the watch source
</span></span><span class=line><span class=cl>    store Store
</span></span><span class=line><span class=cl>    // listerWatcher is used to perform lists and watches.
</span></span><span class=line><span class=cl>    listerWatcher ListerWatcher
</span></span><span class=line><span class=cl>    // period controls timing between one watch ending and
</span></span><span class=line><span class=cl>    // the beginning of the next one.
</span></span><span class=line><span class=cl>    period       time.Duration
</span></span><span class=line><span class=cl>    resyncPeriod time.Duration
</span></span><span class=line><span class=cl>    ShouldResync func() bool
</span></span><span class=line><span class=cl>    // clock allows tests to manipulate time
</span></span><span class=line><span class=cl>    clock clock.Clock
</span></span><span class=line><span class=cl>    // lastSyncResourceVersion is the resource version token last
</span></span><span class=line><span class=cl>    // observed when doing a sync with the underlying store
</span></span><span class=line><span class=cl>    // it is thread safe, but not synchronized with the underlying store
</span></span><span class=line><span class=cl>    lastSyncResourceVersion string
</span></span><span class=line><span class=cl>    // lastSyncResourceVersionMutex guards read/write access to lastSyncResourceVersion
</span></span><span class=line><span class=cl>    lastSyncResourceVersionMutex sync.RWMutex
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><h3 id=sharedprocessor>sharedProcessor</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type sharedProcessor struct {
</span></span><span class=line><span class=cl>    listenersStarted bool
</span></span><span class=line><span class=cl>    listenersLock    sync.RWMutex
</span></span><span class=line><span class=cl>    listeners        []*processorListener
</span></span><span class=line><span class=cl>    syncingListeners []*processorListener
</span></span><span class=line><span class=cl>    clock            clock.Clock
</span></span><span class=line><span class=cl>    wg               wait.Group
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><h3 id=processlistner>processListner</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type processorListener struct {
</span></span><span class=line><span class=cl>    nextCh chan interface{}
</span></span><span class=line><span class=cl>    addCh  chan interface{}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    handler ResourceEventHandler
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // pendingNotifications is an unbounded ring buffer that holds all notifications not yet distributed.
</span></span><span class=line><span class=cl>    // There is one per listener, but a failing/stalled listener will have infinite pendingNotifications
</span></span><span class=line><span class=cl>    // added until we OOM.
</span></span><span class=line><span class=cl>    // TODO: This is no worse than before, since reflectors were backed by unbounded DeltaFIFOs, but
</span></span><span class=line><span class=cl>    // we should try to do something better.
</span></span><span class=line><span class=cl>    // RingGrowing 是一个动态增长的循环队列
</span></span><span class=line><span class=cl>    pendingNotifications buffer.RingGrowing
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><h2 id=疑问>疑问</h2><h3 id=为什么需要-waitforcachesync>为什么需要 waitForCacheSync</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (f *DeltaFIFO) HasSynced() bool {
</span></span><span class=line><span class=cl>    f.lock.Lock()
</span></span><span class=line><span class=cl>    defer f.lock.Unlock()
</span></span><span class=line><span class=cl>    return f.populated &amp;&amp; f.initialPopulationCount == 0
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><code>waitForCacheSync</code> 最终回调用 <code>DeltaFIFO.HasSynced</code> 函数来确定当前 cache 缓存全部写入 workqueue 中。
在 调用 <code>DeltaFIFO.Add</code>，以及 reflector list 完成资源，通过调用 replace 写入 deltafifo 时会 <code>f.populated</code> 置为 true。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (f *DeltaFIFO) Add(obj interface{}) error {
</span></span><span class=line><span class=cl>    f.lock.Lock()
</span></span><span class=line><span class=cl>    defer f.lock.Unlock()
</span></span><span class=line><span class=cl>    f.populated = true
</span></span><span class=line><span class=cl>    ......
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func (r *Reflector) ListAndWatch(stopCh &lt;-chan struct{}) error {
</span></span><span class=line><span class=cl>    ......
</span></span><span class=line><span class=cl>    list, err := r.listerWatcher.List(options)
</span></span><span class=line><span class=cl>    ......
</span></span><span class=line><span class=cl>    items, err := meta.ExtractList(list)
</span></span><span class=line><span class=cl>    ......
</span></span><span class=line><span class=cl>    if err := r.syncWith(items, resourceVersion); err != nil {
</span></span><span class=line><span class=cl>        return fmt.Errorf(&#34;%s: Unable to sync list result: %v&#34;, r.name, err)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    ......
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// syncWith replaces the store&#39;s items with the given list.
</span></span><span class=line><span class=cl>func (r *Reflector) syncWith(items []runtime.Object, resourceVersion string) error {
</span></span><span class=line><span class=cl>    found := make([]interface{}, 0, len(items))
</span></span><span class=line><span class=cl>    for _, item := range items {
</span></span><span class=line><span class=cl>        found = append(found, item)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    return r.store.Replace(found, resourceVersion)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func (f *FIFO) Replace(list []interface{}, resourceVersion string) error {
</span></span><span class=line><span class=cl>    ......
</span></span><span class=line><span class=cl>    if !f.populated {
</span></span><span class=line><span class=cl>        f.populated = true
</span></span><span class=line><span class=cl>        f.initialPopulationCount = len(items)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    ......
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>而 <code>f.initialPopulationCount</code> 只有在 list 的所有资源都被 pop 后，才会被重新赋值为0：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (f *FIFO) Pop(process PopProcessFunc) (interface{}, error) {
</span></span><span class=line><span class=cl>    f.lock.Lock()
</span></span><span class=line><span class=cl>    defer f.lock.Unlock()
</span></span><span class=line><span class=cl>    for {
</span></span><span class=line><span class=cl>        // 并发验证
</span></span><span class=line><span class=cl>        for len(f.queue) == 0 {
</span></span><span class=line><span class=cl>            // When the queue is empty, invocation of Pop() is blocked until new item is enqueued.
</span></span><span class=line><span class=cl>            // When Close() is called, the f.closed is set and the condition is broadcasted.
</span></span><span class=line><span class=cl>            // Which causes this loop to continue and return from the Pop().
</span></span><span class=line><span class=cl>            if f.IsClosed() {
</span></span><span class=line><span class=cl>                return nil, FIFOClosedError
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            f.cond.Wait()
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        id := f.queue[0]
</span></span><span class=line><span class=cl>        f.queue = f.queue[1:]
</span></span><span class=line><span class=cl>        if f.initialPopulationCount &gt; 0 {
</span></span><span class=line><span class=cl>            f.initialPopulationCount--
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        .......
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>所以，根据源码分析，调用 <code>waitForCacheSync</code> 是等待第一次 list 完全部资源后，并且 list 的资源全部写入到 <code>workqueue</code> 后再启动对应的 work，处理事件。这样，降低了 list 大量资源时高并发资源处理资源问题。</p><h3 id=为什么使用-workqueue->为什么使用 workqueue ？</h3><p>在一些 informer demo，以及 operator framework 的代码里面，都能看到 Add、Update、Delete 事件都要先写到 workqueue 中，然后再异步消费。不知道有没有思考过，为什么要加入 workqueue，而不是在事件函数里直接起一个协程来处理事件?</p><p>首先，考虑一个场景 <code>Add -> Deleted -> Add</code>，如果并发处理同一个资源，会不会存在问题？针对顺序依赖问题，最简单方式就是使用队列。那并发执行问题呢？来看一下 worqueue 底层代码是怎么实现的：</p><p><code>k8s.io/client-go/util/workqueue</code> 包有多个文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>default_rate_limiters.go    // 限速器，包含两种，全局限速（BucketRateLimiter）和针对 item 限速（ItemExponentialFailureRateLimiter）
</span></span><span class=line><span class=cl>delaying_queue.go           // 延迟队列，支持延迟添加，队列使用的 queue 
</span></span><span class=line><span class=cl>parallelizer.go             // 并发控制器，
</span></span><span class=line><span class=cl>queue.go                    // 队列，会对添加的 key 去重，同一个 key 同时只会处理一次
</span></span><span class=line><span class=cl>rate_limitting_queue.go     // 限速队列包装器，组合延迟队列、
</span></span></code></pre></td></tr></table></div></div><p>在使用 informer 时，经常看到 <code>workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter())</code> 生成一个队列，缓存事件对象的 metaNamespaceKey。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func NewRateLimitingQueue(rateLimiter RateLimiter) RateLimitingInterface {
</span></span><span class=line><span class=cl>    return &amp;rateLimitingType{
</span></span><span class=line><span class=cl>        DelayingInterface: NewDelayingQueue(),
</span></span><span class=line><span class=cl>        rateLimiter:       rateLimiter,
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func DefaultControllerRateLimiter() RateLimiter {
</span></span><span class=line><span class=cl>    return NewMaxOfRateLimiter(
</span></span><span class=line><span class=cl>        // 针对单个 item 限制处理间隔，最小为 5 毫秒，重新入队一次指数增长，最大为 1000 秒延迟
</span></span><span class=line><span class=cl>        // backoff := float64(r.baseDelay.Nanoseconds()) * math.Pow(2, float64(exp))  exp 是重新入队的次数
</span></span><span class=line><span class=cl>        // if backoff &gt; math.MaxInt64 {
</span></span><span class=line><span class=cl>        //     return r.maxDelay
</span></span><span class=line><span class=cl>        // }
</span></span><span class=line><span class=cl>        NewItemExponentialFailureRateLimiter(5*time.Millisecond, 1000*time.Second),
</span></span><span class=line><span class=cl>        // 使用令牌桶限流算法，限制流速为每秒10个，桶大小为 100 能够应对100的突发
</span></span><span class=line><span class=cl>        &amp;BucketRateLimiter{Limiter: rate.NewLimiter(rate.Limit(10), 100)},
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><code>delayQueue</code> 使用一个定时器，和带缓冲 channel（1000）延迟添加需要重新入队的 item，队列定义在 <code>queue.go</code> 中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Type is a work queue (see the package comment).
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Type</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 通过 slice 实现有序队列，在 queue 中的 item 必定在 dirty 中也存在
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>queue</span> <span class=p>[]</span><span class=nx>t</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Add 队列前需要先在这个集合中添加，确保队列中 item 的唯一性
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// processing 中的 item 会临时存在这个里面，调用 Type.Done 才 append 到 queue 中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>dirty</span> <span class=nx>set</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 调用 Get 的 item 保存在这个集合中，同时在 queue 和 dirty 中删除
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>processing</span> <span class=nx>set</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 队列使用信号量保证访问安全和通知等待消费的 worker
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>cond</span> <span class=o>*</span><span class=nx>sync</span><span class=p>.</span><span class=nx>Cond</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>下面了解一下，入队和出队的代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (q *Type) Get() (item interface{}, shutdown bool) {
</span></span><span class=line><span class=cl>    q.cond.L.Lock()
</span></span><span class=line><span class=cl>    defer q.cond.L.Unlock()
</span></span><span class=line><span class=cl>    for len(q.queue) == 0 &amp;&amp; !q.shuttingDown {
</span></span><span class=line><span class=cl>        q.cond.Wait()
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    if len(q.queue) == 0 {
</span></span><span class=line><span class=cl>        // We must be shutting down.
</span></span><span class=line><span class=cl>        return nil, true
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // 代码编译时会有临时寄存器保存中间值
</span></span><span class=line><span class=cl>    // 类似 temp=a, a=b, b=temp
</span></span><span class=line><span class=cl>    item, q.queue = q.queue[0], q.queue[1:]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    q.metrics.get(item)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    q.processing.insert(item)
</span></span><span class=line><span class=cl>    q.dirty.delete(item)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return item, false
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// Add marks item as needing processing.
</span></span><span class=line><span class=cl>func (q *Type) Add(item interface{}) {
</span></span><span class=line><span class=cl>    q.cond.L.Lock()
</span></span><span class=line><span class=cl>    defer q.cond.L.Unlock()
</span></span><span class=line><span class=cl>    if q.shuttingDown {
</span></span><span class=line><span class=cl>        return
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    if q.dirty.has(item) {
</span></span><span class=line><span class=cl>        return
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    q.metrics.add(item)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    q.dirty.insert(item)
</span></span><span class=line><span class=cl>    if q.processing.has(item) {
</span></span><span class=line><span class=cl>        return
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    q.queue = append(q.queue, item)
</span></span><span class=line><span class=cl>    q.cond.Signal()
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>所以，综上使用 <code>workqueue</code> 保证了事件资源的唯一性。另外，消费失败的 item 可以通过调用 <code>ratelimit.AddAfter</code> 和 <code>ratelimit.AddRateLimited</code> 避免了 hotloop 的问题。<code>AddRateLimited</code> 最终回调用 <code>ItemFastSlowRateLimiter.When</code> 函数确保 failure item 的延迟指数增长。</p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/blog/p/kubectl-exec-deepin/><div class=article-image><img src=/blog/p/kubectl-exec-deepin/_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_27040ddd7399aaf289c0ce70ee6592d9.jpg width=250 height=150 loading=lazy alt="Featured image of post 从 kubectl exec 异常问题开始" data-key=kubectl-exec-deepin data-hash="md5-RvYejqai34/Fvx0koXxEpg=="></div><div class=article-details><h2 class=article-title>从 kubectl exec 异常问题开始</h2></div></a></article><article class=has-image><a href=/blog/p/ipvs-caused-problem/><div class=article-image><img src=/blog/p/ipvs-caused-problem/_hu958d513eeefe5556a31d065479ecc5ac_14205_7bffa90d1e66ca9b8184fda08a99dc7e.jpg width=250 height=150 loading=lazy alt="Featured image of post k8s 环境中 ipvs 带来的问题" data-key=ipvs-caused-problem data-hash="md5-jq4GZk3fs+jcbgAHVstwOw=="></div><div class=article-details><h2 class=article-title>k8s 环境中 ipvs 带来的问题</h2></div></a></article><article class=has-image><a href=/blog/p/how-endpoint-flush-ipvs/><div class=article-image><img src=/blog/p/how-endpoint-flush-ipvs/_huf941de4769045cdfa8c9ee7036519a2a_35369_36687b530fa140121781e790cfd060e7.jpg width=250 height=150 loading=lazy alt="Featured image of post endpoint 更新后 vip 转发实现探究" data-key=how-endpoint-flush-ipvs data-hash="md5-YBFrHM/IYy6aZffVHfPvwg=="></div><div class=article-details><h2 class=article-title>endpoint 更新后 vip 转发实现探究</h2></div></a></article><article class=has-image><a href=/blog/p/service-cause-failure/><div class=article-image><img src=/blog/p/service-cause-failure/_hu0a3f1163de68d0b9471979ebf0ecf11e_32400_a354a9a1f5102742bceb4ec236f4ce2f.jpg width=250 height=150 loading=lazy alt="Featured image of post pod 销毁过程引起短时服务不可用" data-key=service-cause-failure data-hash="md5-rC+UhC7sa7h6Y66uIugvQQ=="></div><div class=article-details><h2 class=article-title>pod 销毁过程引起短时服务不可用</h2></div></a></article><article class=has-image><a href=/blog/p/pod-pending-with-enough-resources/><div class=article-image><img src=/blog/p/pod-pending-with-enough-resources/sleep-boy.ba540b47bff96318db80025530254292_hud07293a026e0ecb8feb93a2c733978af_122481_250x150_fill_q75_box_smart1.jpg width=250 height=150 loading=lazy alt="Featured image of post 集群资源充足情况 Pod 出现 schedulfailed" data-key=pod-pending-with-enough-resources data-hash="md5-ulQLR7/5YxjbgAJVMCVCkg=="></div><div class=article-details><h2 class=article-title>集群资源充足情况 Pod 出现 schedulfailed</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2023 jason's 博客</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/blog/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>