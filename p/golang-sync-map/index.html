<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="最近看到了一个文章[1]，其中提到了 sync.map 的一个内存泄露 bug, 本文对 sync.map 进行研究"><title>GO sync.map 探究</title><link rel=canonical href=https://jasonrd.github.io/blog/p/golang-sync-map/><link rel=stylesheet href=/blog/scss/style.min.8191399262444ab68b72a18c97392f5349be20a1615d77445be51e974c144cff.css><meta property="og:title" content="GO sync.map 探究"><meta property="og:description" content="最近看到了一个文章[1]，其中提到了 sync.map 的一个内存泄露 bug, 本文对 sync.map 进行研究"><meta property="og:url" content="https://jasonrd.github.io/blog/p/golang-sync-map/"><meta property="og:site_name" content="jason's 博客"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:published_time" content="2021-12-17T00:00:00+00:00"><meta property="article:modified_time" content="2021-12-17T00:00:00+00:00"><meta name=twitter:site content="@jasonxie666"><meta name=twitter:creator content="@jasonxie666"><meta name=twitter:title content="GO sync.map 探究"><meta name=twitter:description content="最近看到了一个文章[1]，其中提到了 sync.map 的一个内存泄露 bug, 本文对 sync.map 进行研究"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/blog/><img src=/blog/img/avatar_hu92a1f0f4dac05816138a9efb01424f59_787601_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a>
<span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/blog>jason's 博客</a></h1><h2 class=site-description>Welcom</h2></div></header><ol class=social-menu><li><a href=https://github.com/JasonRD target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com/jasonxie666 target=_blank title=Twitter rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/blog/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>主页</span></a></li><li><a href=/blog/%E5%85%B3%E4%BA%8E/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>关于</span></a></li><li><a href=/blog/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/blog/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><li><a href=/blog/links/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg><span>Links</span></a></li><div class=menu-bottom-section><li id=i18n-switch><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg><select name=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://jasonrd.github.io/blog/en/>English</option><option value=https://jasonrd.github.io/blog/ selected>中文</option></select></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#背景>背景</a></li><li><a href=#源码分析>源码分析</a><ol><li><a href=#数据结构>数据结构</a></li><li><a href=#接口分析>接口分析</a><ol><li><a href=#store-逻辑>Store 逻辑：</a></li><li><a href=#load-逻辑>Load 逻辑</a></li><li><a href=#delete-逻辑>Delete 逻辑</a></li></ol></li></ol></li><li><a href=#总结>总结</a></li><li><a href=#reference>reference</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/blog/categories/golang/>golang</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/blog/p/golang-sync-map/>GO sync.map 探究</a></h2><h3 class=article-subtitle>最近看到了一个文章[1]，其中提到了 sync.map 的一个内存泄露 bug, 本文对 sync.map 进行研究</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Dec 17, 2021</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 3 分钟</time></div></footer></div></header><section class=article-content><h2 id=背景>背景</h2><p>最近看到了一个文章[1]，其中提到了 sync.map 的一个bug，key 如果使用连接，会导致连接泄漏。文中提到了具体原因是 sync.map 对 key 删除是软删除，只是将 可以对应的 value 置为 nil，key 还会继续存在。</p><p>根据文章中描述，发现自己对 sync.Map 了解不够透彻，所以就打算进行一番了解。sync.Map 是 go 标准库中实现的线程安全的 Map，主要适用的场景：</p><blockquote><blockquote><p>The Map type is optimized for two common use cases:
(1) when the entry for a given key is only ever written once but read many times, as in caches that only grow, or
(2) when multiple goroutines read, write, and overwrite entries for disjoint sets of keys. In these two cases, use of a Map may significantly reduce lock contention compared to a Go map paired with a separate Mutex or RWMutex.</p></blockquote></blockquote><ol><li>同一个 key 读多写少；</li><li>并发读、写、覆盖不同 key；</li></ol><p>其中，sync.Map 包中提到，在这两种场景中性能要优于使用 Map + Mutex。接下来我们看一下如何实现的，为什么在这两种场景下性能有优势。</p><h2 id=源码分析>源码分析</h2><h3 id=数据结构>数据结构</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type Map struct {
</span></span><span class=line><span class=cl>    mu Mutex
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // 只读区，保存部分健值对
</span></span><span class=line><span class=cl>    // 修改时进行原子性替换
</span></span><span class=line><span class=cl>    read atomic.Value
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // 新写入的健值对，先保存到 dirty 中
</span></span><span class=line><span class=cl>    // 更新或者被删除的，dirty 中不会存储 expunged 健值对
</span></span><span class=line><span class=cl>    dirty map[interface{}]*entry
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // 记录 Load 出现多少次在 dirty 中读取健值对情况。
</span></span><span class=line><span class=cl>    misses int
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 存储 value 的指针
</span></span><span class=line><span class=cl>// key 被删除时通过 CAS 修改为 nil 或 expunged
</span></span><span class=line><span class=cl>type entry struct {
</span></span><span class=line><span class=cl>    p unsafe.Pointer // *interface{}
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>type readOnly struct {
</span></span><span class=line><span class=cl>    // 存储的部分健值对，只会 m 中元素
</span></span><span class=line><span class=cl>    // 不会存在并发读写情况。
</span></span><span class=line><span class=cl>    m       map[interface{}]*entry
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // dirty 中是否有 read.m 中不存在的健值对
</span></span><span class=line><span class=cl>    amended bool // true if the dirty map contains some key not in m.
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>sync.Map 中使用了两个 map 对象来尽量避免锁竞争，相当于增加一个缓冲。其中 read map 中记录部分健值对，dirty 中保存新写入的 value 和 read.m 中未被标记为 expunged 或 nil 的 entry。</p><h3 id=接口分析>接口分析</h3><p><img src=/blog/p/golang-sync-map/img/map-store.jpg width=1944 height=1380 srcset="/blog/p/golang-sync-map/img/map-store_hu2f1e02e515e351c311ec896043222feb_441700_480x0_resize_q75_box.jpg 480w, /blog/p/golang-sync-map/img/map-store_hu2f1e02e515e351c311ec896043222feb_441700_1024x0_resize_q75_box.jpg 1024w" loading=lazy class=gallery-image data-flex-grow=140 data-flex-basis=338px></p><h4 id=store-逻辑>Store 逻辑：</h4><ol><li>判断 read.m 中是否存在key。<ul><li>如果存在进行尝试更新，会起一个循环不停尝试 CAS 更新，更新成功则返回。</li><li>如果read.m 中不存在 key，或者更新过程中发现 key 对应 entry 已被标记为 expunged，则进行第二步；</li><li>可以看出如果更新某个 key (已经在 read.m 中，并且未被删除) ，更新并不会加锁</li></ul></li><li>加锁，再次判断 read.m 中是否存在<ul><li>如果存在，然后判断之前 entry 是否为 expunged 状态，如果是（说明 dirty 中不存在 key），则把 key-entry 写入 dirty map 中；然后，原子更新 entry.p 指针。</li><li>否则进行第三步</li></ul></li><li>dirty map 中是否存在 key，如果存在，则直接原子更新 entry.p 指针；否则，进行第四步；</li><li>read 和 dirty 中都不存在目标 key，则添加到 dirty 中。添加会做一些数据同步操作：<ul><li>如果 read.m 不需要进行修正（ read.amended = false），则同步 read.m 中为被删除（enty.p!=nil or expunged）健值对到 dirty map 中。并通过 CAS 操作更新read.m 中被删除的 entry（enty.p = nil）标记为 expunged。</li><li>否则，直接添加到 dirty 中。</li></ul></li></ol><h4 id=load-逻辑>Load 逻辑</h4><p><img src=/blog/p/golang-sync-map/img/map-load.jpg width=1748 height=1098 srcset="/blog/p/golang-sync-map/img/map-load_hu2f1e02e515e351c311ec896043222feb_291641_480x0_resize_q75_box.jpg 480w, /blog/p/golang-sync-map/img/map-load_hu2f1e02e515e351c311ec896043222feb_291641_1024x0_resize_q75_box.jpg 1024w" loading=lazy class=gallery-image data-flex-grow=159 data-flex-basis=382px></p><ol><li>read.m 中是否存在，如果存在，判断是否已被删除，并返回相应状态；否则，进行下一步；</li><li>判断 read.amended 状态：<ul><li>如果需要修正，进行加锁，然后再一次判断 read.m 和 read.amended，避免并发过程中 read 出现更新；</li><li>获取 dirty 中 key，并更新 miss 次数；如果 miss 次数达到 dirty.length，则更新read，并置 dirty=nil;</li><li>释放锁；</li></ul></li><li>判断是否存在 key，或者是否被删除，进行相应返回</li></ol><h4 id=delete-逻辑>Delete 逻辑</h4><p><img src=/blog/p/golang-sync-map/img/map-delete.jpg width=1006 height=1070 srcset="/blog/p/golang-sync-map/img/map-delete_hu2f1e02e515e351c311ec896043222feb_158336_480x0_resize_q75_box.jpg 480w, /blog/p/golang-sync-map/img/map-delete_hu2f1e02e515e351c311ec896043222feb_158336_1024x0_resize_q75_box.jpg 1024w" loading=lazy class=gallery-image data-flex-grow=94 data-flex-basis=225px></p><p>删除和 Load key 逻辑类似。</p><ol><li>首先，判断 read 中是否存在，如果存在，则标记 entry.p 为nil；如果不存在，继续判断 amended ；</li><li>加锁，进行二次判断，然后调用 delete 删除 dirty map 中 key；释放锁；</li></ol><h2 id=总结>总结</h2><ol><li>read.m 中存在的 key 并非读写不会加锁，进行原子更新；所以，对于同一个 key 进行读写，具有较优的性能；</li><li>写入时，优先写入 dirty map，对于其他已经存在于 read.m 中的 key 读写并没有性能影响；</li></ol><p>通过上面写入、删除、获取逻辑，可以看出：</p><ol><li>key 大部分是软删除，即标记 entry.p 为 nil 或 expunged。只有在<code>删除->新增->读取->(missed > dirty.length)->修正read.m</code>情况会通过 GC 自动删除 key。</li><li>read.amended 标示存在某些 key 只存在 dirty 中；</li><li>read.m 更新是在 missed 次数达到阈值（dirty.length）时，直接进行原子覆盖。<ul><li>为什么不 miss 一次进行一次更新？</li></ul></li><li>dirty 为 nil 情况：未被使用的 map；miss 超过阈值时；</li><li>持有锁情况：修改 dirty、修正 read；</li><li>看代码时对 store 中判断，<code>entry.unexpungeLocked</code> 时对 dirty 才写入 key。对这个逻辑有个疑问，为什么 entry 为 expunged 状态说明 dirty 不为 nil ，并且其中不存在该 key 呢？<ul><li>通过下图能够看到，enrty 只有 read.m 与 dirty 同步逻辑中才会修改为 expunged; 并且同步过程不会同步被删除的 key；所以，expunged 状态的 key 不会存在于 dirty 中。</li><li>如5，dirty map 为 nil 只有两种情况，所以只有修正read 情况。因为 read.m 中包含 key，所以并没有进行原子更新 read。这样，就会出现 dirty =nil 情况；</li></ul></li><li>dirty 中不会包含 expunged 状态的 entry，并且包含所有有效 key；</li></ol><p><img src=/blog/p/golang-sync-map/img/map-entry-state.jpg width=1206 height=1168 srcset="/blog/p/golang-sync-map/img/map-entry-state_hu2f1e02e515e351c311ec896043222feb_220210_480x0_resize_q75_box.jpg 480w, /blog/p/golang-sync-map/img/map-entry-state_hu2f1e02e515e351c311ec896043222feb_220210_1024x0_resize_q75_box.jpg 1024w" loading=lazy class=gallery-image data-flex-grow=103 data-flex-basis=247px></p><h2 id=reference>reference</h2><ol><li><a class=link href=https://purewhite.io/2020/08/24/golang-sync-map-keys-never-delete/ target=_blank rel=noopener>sync.Map 引起的 bug</a></li><li><a class=link href=https://halfrost.com/go_map_chapter_one/ target=_blank rel=noopener>如何实现一个线程安全的map</a></li></ol></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/blog/p/golang-rwmutex-deadlock/><div class=article-image><img src=/blog/p/golang-rwmutex-deadlock/daedlock.15d5d266eb14d23a5c933e1775b8ea74_hu26d071d1a9c611a8342c73b77f908c12_41977_250x150_fill_q75_box_smart1.jpeg width=250 height=150 loading=lazy alt="Featured image of post GO RWMutex 中隐藏的死锁问题" data-key=golang-rwmutex-deadlock data-hash="md5-FdXSZusU0jpckz4XdbjqdA=="></div><div class=article-details><h2 class=article-title>GO RWMutex 中隐藏的死锁问题</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2023 jason's 博客</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/blog/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>